<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta http-equiv="Content-Language" content="en-us">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
  <link rel="stylesheet" type="text/css" href="../../../boost.css">
  <link rel="stylesheet" type="text/css" href="images/bpt_styles.css">  

  <title>boost_comparison</title>
</head>

<body link="#0000FF" vlink="#800080">
  <table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
  "header">
    <tr>
      <td valign="top" width="300">
        <h3><a href="../../../index.htm"><img height="86" width="277" alt=
        "C++ Boost" src="images/boost.png" border="0"></a></h3>
      </td>
    </tr>
  </table>

  
  <hr>  
  <div align="right">
    <a href="introduction.html"><img src="images/prev.png" border=0 alt="Prev"></a>
    <a href="../index.html"><img src="images/up.png" border=0 alt="Up"></a>
    <a href="../index.html"><img src="images/home.png" border=0 alt="Home"></a>
    <a href="examples.html"><img src="images/next.png" border=0 alt="Next"></a>    
  </div> 
  
  

<h2 align="left">  
    Comparison with Boost.Container and Boost.MultiIndex libraries
</h2>
  
    <p>
    This section provides the comparison of STL containers using augmented B+ trees 
    with the following Boost libraries: <b>Boost.Container</b> and <b>Boost.MultiIndex</b>. 
    <b>Boost.Intrusive</b> is out of scope of this comparison, since intrusive containers 
    do not support copy semantics and, thus, they are not STL compliant.     
    </p>
  

<div class="div_f1_frame"> 
  <dl>
    <dd class="dd_f1"><a class="link_under" href="#boost_container">Comparison with Boost.Container library</a></dd>
    <dd class="dd_f1"><a class="link_under" href="#boost_multi_index">Comparison with Boost.MultiIndex library</a></dd>
  </dl>
</div>
<br>


    <a name="boost_container"></a>
    <h4 class="h4_f1">
    Comparison with Boost.Container library
    </h4>
    
    <p>  
    The 
    <a href="http://www.boost.org/doc/libs/1_51_0/doc/html/container.html"><b>Boost.Container</b> library</a>     
    provides a number of features that are currently not available in the 
    containers of the namespace <code>std_ext_adv</code>. <b>Boost.Container</b> 
    offers almost complete support for the C++11 standard features, 
    such as move semantics, and backports this support to C++03 compliant 
    compilers. The list of other useful features includes type erasure, 
    recursive types and the compatibility with <b>Boost.Interprocessor</b>.
    The containers of the namespace <code>std_ext_adv</code> 
    currently conform to the C++03 standard only. 
    </p>  
  
    <p>  
    The <b>Boost.Container</b> library includes a wide variety of both 
    standard and non-standard containers that support STL interfaces. 
    This section discusses the non-standard Boost containers 
    with the main focus on the comparison of extensions of the STL facilities 
    offered by both libraries. 
    </p>  


    <h4>
    <code>stable_vector</code> 
    </h4>
  
    <p>  
    Out of all the non-standard Boost containers <code>stable_vector</code> is 
    particularly interesting, since it combines features of both array based and 
    dynamically allocated data structures. This container has the same interface 
    and the same computational complexities of operations as <code>std::vector</code>. 
    The main advantage of <code>stable_vector</code> is that its random access 
    iterators and references to elements are not invalidated by update operations 
    unless an element pointed to by an iterator or a reference is erased. 
    This functionality is implemented through an array that stores in its cells 
    pointers to nodes with elements. A node with a container element has a reverse 
    link to an array cell with a pointer that points to the node. An iterator of 
    this container remains valid, since insert and erase operations modify 
    the pointer array only. The nodes are not moved in the memory space and 
    the container elements are accessed through pointers to the nodes. 
    The stability of random access iterators, however, comes at the expense of 
    worse locality of reference compared to <code>std::vector</code>. 
    </p>  
  
    <p>  
    The augmented B+ trees have two options to provide 
    this facility of the <code>stable_vector</code> container. 
    The <a href="https://github.com/vstadnik/stl_ext_adv">dynamically allocated B+ trees</a> 
    offer iterators that have properties of both random access and bidirectional iterators. 
    The computational cost of some operations supporting this functionality is logarithmic. 
    The array based B+ trees should be more efficient provided that they implement 
    the key idea of <code>stable_vector</code>. This variant of a B+ tree would 
    partition the pointer array of a <code>stable_vector</code> into a list of 
    sub-arrays storing pointers to nodes with the container elements. 
    These data structures should be beneficial for algorithms processing large objects, 
    since operations with pointers are much cheaper in this case. 
    STL containers, both sequences and associative containers, using these 
    specialized array based B+ trees will obtain the advantage of efficient 
    logarithmic time insert, erase, splice and split operations that are 
    not achievable with <code>stable_vector</code>.     
    </p>  


    <h4>
    <code>flat_(multi)map/set</code>
    </h4>
  
    <p>  
    The associative containers <code>flat_(multi)map/set</code> represent 
    ordered vectors that support interfaces of the matching standard containers 
    based on dynamically allocated red black trees. The contiguous arrangement of 
    elements improves the use of space and locality of reference. 
    These new containers offer more efficient random access iterators and 
    faster search by key than the standard containers. The disadvantage of 
    these containers is relatively high linear cost of insert and erase operations.     
    </p>  

    <p>
    The data structures of the namespace <code>std_ext_adv</code> take advantage 
    of the efficient pointer arithmetic and, thus, offer similar improvements 
    for the associative containers. These containers support efficient access to 
    the container elements by their keys and positions. Compared to 
    <b>Boost.Container</b> their random access iterators are a bit less efficient 
    due to logarithmic cost of moving to a distant position. Locality of reference 
    is also a bit worse than in array based associative containers of 
    <b>Boost.Container</b>, since augmented B+ trees implement a partition of 
    an array. Nevertheless, this parameter is much better than in dynamically 
    allocated red black trees of the standard containers. Unlike Boost array based 
    containers, the associative containers of the namespace <code>std_ext_adv</code> 
    do not have the disadvantage of inefficient insert and erase operations. 
    Additionally, they support logarithmic time split operations in the general case 
    and merge operations in special cases. 
    </p>  


    <h4>
    <code>slist</code>
    </h4>

    <p>  
    The <b>Boost.Container</b> <code>slist</code> compliments the C++11 container 
    <code>forward_list</code> by adding constant time function <code>size()</code>. 
    As a result of this feature the running time of one of the standard functions 
    <code>splice_after()</code> increases from constant to linear. To improve 
    performance of a user algorithm this container provides the new 
    <code>splice_after()</code> function with constant computational complexity. 
    However, this function assumes that a user algorithm controls and counts 
    the number of moved elements.     
    </p>  
  
    <p>  
    The sequences of the namespace <code>std_ext_adv</code> support splice and 
    split operations with logarithmic running time without any restrictions. 
    Their random access iterators are more efficient and provide more extensive 
    set of operations than forward iterators of <code>slist</code>. 
    </p>  
  
    
    <h4>
    Discussion
    </h4>

    <p>
    In both compared libraries the STL extensions are achieved through 
    new types of non-standard containers. <b>Boost.Container</b> supports 
    the extensions by implementing a wide variety of containers with 
    a relatively small number of specific improvements in each container. 
    The namespace <code>std_ext_adv</code> provides a small number of basic containers, 
    but each of them supports a wide variety of STL sequences and associative containers. 
    </p>  
  
    <p>
    This difference between two libraries is significant for the performance of 
    complex algorithms, since a set of <i>N</i> specialized containers with one efficient 
    member function or iterator in each is normally less beneficial than one container 
    with a set of <i>N</i> efficient member functions required in a user algorithm. 
    This performance benefit is provided by advanced data structures and it is not 
    achievable with data structures used in <b>Boost.Container</b> and the C++ standard library.
    </p>  

    
    <h4>
    Summary
    </h4>

  <ul>
    <li class="li_sum">
    <code><b>(+)</b></code> <b>Boost.Container</b> offers a number of features, 
    such as C++11 move semantics, type erasure and recursive data types, that are 
    currently not supported by the containers of the namespace <code>std_ext_adv</code>. 
    </li>    
    
    <li class="li_sum">
    <code><b>(=)</b></code> The containers of the namespace <code>std_ext_adv</code> 
    support stable iterators of Boost <code>stable_vector</code> through dynamically 
    allocated B+ trees and can support through specialized array based B+ trees. 
    </li>    
    
    <li class="li_sum">
    <code><b>(=)</b></code> Both libraries provide containers with improved 
    use of space and locality of reference against the standard containers 
    based on dynamically allocated data structures. 
    </li>    
    
    <li class="li_sum">
    <code><b>(=)</b></code> Both libraries offer associative containers with 
    random access iterators and efficient search by keys. 
    </li>    
    
    <li class="li_sum">
    <code><b>(-)</b></code> The array based containers of <b>Boost.Container</b>, 
    including non-standard associative containers and <code>stable_vector</code>, 
    have inefficient linear time insert and erase operations 
    for a single element anywhere within a container. 
    </li>    
    
    <li class="li_sum">
    <code><b>(-)</b></code> <b>Boost.Container</b> library does not implement 
    optimized memory management for the array based containers. 
    </li>
    
    <li class="li_sum">
    <code><b>(-)</b></code> The containers of <b>Boost.Container</b> do not support 
    general efficient splice and split operations. 
    </li>    
    
    <li class="li_sum">
    <code><b>(-)</b></code> Boost containers do not offer logarithmic time 
    <code>accumulate()</code> algorithm. 
    </li>
    
    <li class="li_sum">
    <code><b>(-)</b></code> The <b>Boost.Container</b> sequences are not completely 
    interchangeable due to differences in interfaces similar to the standard containers. 
    None of them can match the wide set of efficient operations of 
    <code>std_ext_adv::sequence</code>. 
    </li>    
    
    <li class="li_sum">
    <code><b>(-)</b></code> Boost containers do not reach the level of 
    generalization of containers of the namespace <code>std_ext_adv</code>. 
    </li>    
    
  </ul>

    
    <h4>
    Conclusion
    </h4>

    <p>  
    This brief comparison shows that there are many useful STL extensions already 
    implemented in the compared libraries. Other data structures, first of all 
    augmented red black trees, can provide similar and new improvements to 
    the C++ standard facilities. 
    </p>  

    <p>  
    In the general case, a new STL extension can be added to a library 
    if there is a performance gain for user algorithms offered by 
    a new data structure or by a new algorithm or there is a new useful facility, 
    such as random access iterators not invalidated by update operations. 
    This is why the challenge for every library that offers STL facilities 
    with extensions is to find the best implementation method that takes 
    advantage of any beneficial data structure that can support STL interfaces of 
    containers and iterators. The namespace <code>std_ext_adv</code> solves 
    this task using the container adapters. 
    </p>  

    <p>  
    The <b>Boost.Container</b> library should offer a solution that will allow integrating 
    not only all of the already implemented, but also future extensions provided by new 
    data structures and algorithms. This library should be open for the maximum possible 
    number of new STL extensions. When this solution is tested and is proven to be 
    useful and successful it can be proposed for the C++1y STL. The new level of 
    efficiency of the STL facilities using a wide range of data structures and algorithms 
    will give the C++ programming language a highly competitive advantage. 
    </p>  
    

    <h4>
    Comparison of performance
    </h4>
    
    <p>
    Each sequence or associative container of the namespace <code>std_ext_adv</code> 
    offers a wider set of efficient operations than any matching container of 
    the standard and <b>Boost.Container</b> libraries. The performance benefit of 
    new containers for user algorithms can be demonstrated with the following simple test, 
    see the source code in the file <code>&quot;boost_performance.cpp&quot;</code>, 
    that moves an iterator to a specified position and inserts a new element: 
    </p>
    
<pre>
    std::advance ( pos , dist ) ;               //  C1
    constainer . insert ( pos , val_new ) ;     //  C2 
</pre>

    <p>  
    For all the types of containers based on dynamically allocated linked lists 
    and red black trees the computational complexity of the first operation 
    <code>C1</code> is <i>O(N)</i>, <code>C2</code> varies between <i>O(1)</i> and 
    <i>O(log N)</i>. For all the types of array based containers, including 
    <code>std::vector</code> and Boost <code>stable_vector</code>, 
    <code>C1</code> = <i>O(1)</i> and <code>C2</code> = <i>O(N)</i>. 
    Thus, the total cost of these two operations is <i>O(N)</i> for all of 
    these containers. When these two operations are performed inside a loop 
    the running time of the test is quadratic. For a large number of elements 
    such loop creates a performance bottleneck. 
    </p>  
    
    <p>  
    The augmented B+ trees, both dynamically allocated and array based, 
    perform much better in this test. For any of the new containers 
    the total running time is <i>O(N log N)</i>, since both basic 
    operations have the same computational complexity 
    <code>C1 = C2 = </code> <i>O(log N)</i> in the worst case. 
    </p>  

    <p>  
    In all the following tables <code>sequence_array</code> and <code>multiset_array</code> 
    denote containers <code>std_ext_adv::sequence</code> and <code>std_ext_adv::multiset</code> 
    using array based B+ trees, 
    <code>sequence_list</code> - container <code>std_ext_adv::sequence</code> using a 
    <a href="https://github.com/vstadnik/stl_ext_adv">dynamically allocated augmented B+ tree</a>; 
    <code>boost::flat_multiset</code> denotes <code>boost::container::flat_multiset</code> 
    and <code>boost::stable_vector</code> denotes <code>boost::container::stable_vector</code>. 
    Tested libraries: the standard containers of MSVC++ 9, <b>Boost.Container</b> version 1.51. 
    The system parameters: Intel Core 2 Duo Processor E6400, 2.13GHz, 
    2.00MB of L2 Cache, 2.00GB of RAM, Windows XP 32 bits. 
    </p>
    
    <p>      
    The first table shows values of running times of the discussed test in milliseconds 
    against the number of elements. The results are consistent with the estimates of 
    computational complexities. 
    </p>  
    
  <table class="tbl_f1">
    <tr>
        <td class="td_f1"><b><i>N</i></b></td>  
        <td class="td_f1_rt"><b><i>1.0e+3</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+4</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+5</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+6</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+7</i></b></td>
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_array</code></td>  
        <td class="td_f1_rt">2.7e-1</td>
        <td class="td_f1_rt">2.7e+0</td>
        <td class="td_f1_rt">3.3e+1</td>
        <td class="td_f1_rt">6.2e+2</td>
        <td class="td_f1_rt">1.4e+4</td>
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_list</code></td>  
        <td class="td_f1_rt">2.7e-1</td>
        <td class="td_f1_rt">3.3e+0</td>
        <td class="td_f1_rt">5.1e+1</td>
        <td class="td_f1_rt">1.4e+3</td>
        <td class="td_f1_rt">2.2e+4</td>
    </tr>
    <tr>
        <td class="td_f1"><code>multiset_array</code></td>  
        <td class="td_f1_rt">4.0e-1</td>
        <td class="td_f1_rt">4.4e+0</td>
        <td class="td_f1_rt">6.0e+1</td>
        <td class="td_f1_rt">1.1e+3</td>
        <td class="td_f1_rt">3.1e+4</td>
    </tr>
    <tr>
        <td class="td_f1"><code>std::vector</code></td>  
        <td class="td_f1_rt">2.7e-1</td>
        <td class="td_f1_rt">1.6e+1</td>
        <td class="td_f1_rt">2.2e+3</td>
        <td class="td_f1_rt">3.5e+5</td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>boost::vector</code></td>  
        <td class="td_f1_rt">2.1e-1</td>
        <td class="td_f1_rt">1.5e+1</td>
        <td class="td_f1_rt">2.2e+3</td>
        <td class="td_f1_rt">3.5e+5</td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>boost::flat_multiset</code></td>  
        <td class="td_f1_rt">2.4e-1</td>
        <td class="td_f1_rt">1.5e+1</td>
        <td class="td_f1_rt">2.0e+3</td>
        <td class="td_f1_rt">3.0e+5</td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>boost::stable_vector</code></td>  
        <td class="td_f1_rt">6.6e-1</td>
        <td class="td_f1_rt">1.1e+2</td>
        <td class="td_f1_rt">1.3e+4</td>
        <td class="td_f1_rt">6.2e+6</td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>boost::list</code></td>  
        <td class="td_f1_rt">4.9e-1</td>
        <td class="td_f1_rt">1.3e+2</td>
        <td class="td_f1_rt">2.1e+4</td>
        <td class="td_f1_rt"> - </td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>std::list</code></td>  
        <td class="td_f1_rt">1.3e+0</td>
        <td class="td_f1_rt">2.0e+2</td>
        <td class="td_f1_rt">2.7e+4</td>
        <td class="td_f1_rt"> - </td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>boost::multiset</code></td>  
        <td class="td_f1_rt">3.0e+0</td>
        <td class="td_f1_rt">3.8e+2</td>
        <td class="td_f1_rt">4.5e+4</td>
        <td class="td_f1_rt"> - </td>
        <td class="td_f1_rt"> - </td>
    </tr>
    <tr>
        <td class="td_f1"><code>std::multiset</code></td>  
        <td class="td_f1_rt">4.0e+0</td>
        <td class="td_f1_rt">4.7e+2</td>
        <td class="td_f1_rt">6.4e+4</td>
        <td class="td_f1_rt"> - </td>
        <td class="td_f1_rt"> - </td>
    </tr>
  </table>

    
    <p>
    The efficiency of access to data stored in a container can significantly 
    affect the performance of user algorithms. This factor is particularly 
    important for dynamically allocated data structures, since they have 
    worse locality of reference than array based data structures 
    that store elements contiguously. The variation of performance 
    associated with locality of reference can be estimated using 
    the sequential algorithm <code>std::accumulate()</code>, which is 
    applied to containers constructed in the previous test. The following table 
    shows values of running times in microseconds against the number of elements.    
    </p>
    
  <table class="tbl_f1">
    <tr>
        <td class="td_f1"><b><i>N</i></b></td>  
        <td class="td_f1_rt"><b><i>1.0e+3</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+4</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+5</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+6</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+7</i></b></td>
    </tr>
    <tr>
        <td class="td_f1"><code>std::vector</code></td>  
        <td class="td_f1_rt">6.4e+0</td>
        <td class="td_f1_rt">7.0e+1</td>    
        <td class="td_f1_rt">6.9e+2</td>    
        <td class="td_f1_rt">9.6e+3</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>boost::vector</code></td>  
        <td class="td_f1_rt">6.4e+0</td>    
        <td class="td_f1_rt">7.0e+1</td>    
        <td class="td_f1_rt">6.9e+2</td>    
        <td class="td_f1_rt">9.7e+3</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_array</code></td>  
        <td class="td_f1_rt">2.9e+1</td>    
        <td class="td_f1_rt">2.9e+2</td>    
        <td class="td_f1_rt">3.1e+3</td>    
        <td class="td_f1_rt">4.9e+4</td>  
        <td class="td_f1_rt">5.6e+5</td>  
    </tr>
    <tr>
        <td class="td_f1"><code>boost::stable_vector</code></td>  
        <td class="td_f1_rt">4.0e+1</td>    
        <td class="td_f1_rt">8.8e+2</td>    
        <td class="td_f1_rt">1.4e+4</td>    
        <td class="td_f1_rt">7.5e+5</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>std::list</code></td>  
        <td class="td_f1_rt">2.6e+1</td>    
        <td class="td_f1_rt">7.8e+2</td>    
        <td class="td_f1_rt">2.3e+4</td>    
        <td class="td_f1_rt"> - </td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_list</code></td>  
        <td class="td_f1_rt">3.0e+1</td>    
        <td class="td_f1_rt">8.5e+2</td>    
        <td class="td_f1_rt">2.8e+4</td>    
        <td class="td_f1_rt">7.8e+5</td>  
        <td class="td_f1_rt">9.3e+6</td>  
    </tr>
    <tr>
        <td class="td_f1"><code>std::multiset</code></td>  
        <td class="td_f1_rt">2.7e+2</td>    
        <td class="td_f1_rt">3.1e+3</td>    
        <td class="td_f1_rt">5.8e+4</td>    
        <td class="td_f1_rt"> - </td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
  </table>
    

    <p>  
    For the analysis of this performance test relative costs are 
    more informative than the measured absolute values. In the next table 
    all the running times are normalized by the mean time 
    of a single operation of <code>std::vector</code> at <i>N</i> = 10,000. 
    </p>  
    
  <table class="tbl_f1">
    <tr>
        <td class="td_f1"><b><i>N</i></b></td>  
        <td class="td_f1_rt"><b><i>1.0e+3</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+4</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+5</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+6</i></b></td>
        <td class="td_f1_rt"><b><i>1.0e+7</i></b></td>
    </tr>
    <tr>
        <td class="td_f1"><code>std::vector</code></td>  
        <td class="td_f1_rt">0.9</td>    
        <td class="td_f1_rt">1.0</td>    
        <td class="td_f1_rt">1.0</td>    
        <td class="td_f1_rt">1.4</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>boost::vector</code></td>  
        <td class="td_f1_rt">0.9</td>    
        <td class="td_f1_rt">1.0</td>    
        <td class="td_f1_rt">1.0</td>    
        <td class="td_f1_rt">1.4</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_array</code></td>  
        <td class="td_f1_rt">4.1</td>    
        <td class="td_f1_rt">4.1</td>    
        <td class="td_f1_rt">4.4</td>    
        <td class="td_f1_rt">7.0</td>    
        <td class="td_f1_rt">8.0</td>            
    </tr>
    <tr>
        <td class="td_f1"><code>boost::stable_vector</code></td>  
        <td class="td_f1_rt">5.7</td>    
        <td class="td_f1_rt">13.0</td>    
        <td class="td_f1_rt">20.0</td>    
        <td class="td_f1_rt">105.0</td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>std::list</code></td>  
        <td class="td_f1_rt">3.7</td>    
        <td class="td_f1_rt">11.0</td>    
        <td class="td_f1_rt">33.0</td>    
        <td class="td_f1_rt"> - </td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
    <tr>
        <td class="td_f1"><code>sequence_list</code></td>  
        <td class="td_f1_rt">4.3</td>    
        <td class="td_f1_rt">12.0</td>    
        <td class="td_f1_rt">40.0</td>    
        <td class="td_f1_rt">110.0</td>    
        <td class="td_f1_rt">130.0</td>            
    </tr>
    <tr>
        <td class="td_f1"><code>std::multiset</code></td>  
        <td class="td_f1_rt">38.0</td>    
        <td class="td_f1_rt">44.0</td>    
        <td class="td_f1_rt">83.0</td>    
        <td class="td_f1_rt"> - </td>    
        <td class="td_f1_rt"> - </td>   
    </tr>
  </table>
    

    <p>  
    The worst performance in this test shows <code>std::multiset</code> 
    based on a red black tree. Two other containers using dynamically 
    allocated data structures, <code>std::list</code> and 
    <code>sequence_list</code>, have better running times, however, 
    they increase quite sharply with the increase in the number of container elements. 
    </p>      
    
    <p>      
    The most efficient for sequential processing are <code>vector</code> 
    containers. Unlike containers based on dynamically allocated 
    data structures, their values of running times are relatively small 
    and do not vary much as the number of elements changes. 
    The containers <code>std_ext_adv::sequence</code> and 
    <code>std_ext_adv::multiset</code> using array based B+ trees 
    are less efficient than <code>std::vector</code>, however, 
    the increase in the values of running times is consistent 
    with that in <code>std::vector</code>. 
    This important fact points to good locality of reference 
    of the augmented array based B+ trees. For this reason 
    the performance of new containers remains high 
    even when they store large numbers of elements. 
    </p>      

    <p>  
    The results for Boost hybrid container <code>stable_vector</code> are 
    quite interesting. As an array based container it is less efficient 
    than <code>std::vector</code> and <code>std_ext_adv::sequence</code>. 
    In this test <code>stable_vector</code> has running times close to those 
    of containers using dynamically allocated data structures and 
    its relative cost is similarly sensitive to the number of elements.     
    </p> 

    <p>  
    The standard containers offer various implementation options for 
    user algorithms. In particular, an algorithm that is applied to a sequence of 
    elements can have two different variants using either <code>std::list</code> 
    or <code>std::vector</code>. The <code>std_ext_adv::sequence</code> 
    can replace any of the standard sequences. Hence, the question arises 
    which variant is preferrable for an algorithm using a new container? 
    The results of these performance tests suggest that, normally, 
    a variant based on <code>std::vector</code> should be the first choice, 
    since it offers the advantage of efficient sequential processing. 
    </p>  
    
    

    <a name="boost_multi_index"></a>
    <h4 class="h4_f1">
    Comparison with Boost.MultiIndex library     
    </h4>

    <p>
    The comparison of containers and data structures of the namespace <code>std_ext_adv</code>    
    with <b>Boost.MultiIndex</b> is less trivial than with <b>Boost.Container</b>, 
    since the functionality of the <b>Boost.MultiIndex</b> library is much wider 
    than the functionality of any library of containers.   
    </p>

    <p>
    The 
    <a href="http://www.boost.org/doc/libs/1_51_0/libs/multi_index/doc/index.html"><b>Boost.MultiIndex</b> library</a>     
    offers the facilities of an in-memory relational database. 
    In <b>Boost.MultiIndex</b> an <i>index</i> represents 
    a container or a data structure. The <i>indices</i> support interfaces of 
    STL containers, however, they are not completely STL compliant. 
    The important restrictions are applied to update operations that can be 
    performed only through special non-standard member functions. In addition 
    to this, the <i>indices</i> must remain stable  after the update operations.     
    </p>
    
    <p>
    Several <i>indices</i> can be used in the class template <code>multi_index_container</code> 
    to store a data set and to provide access to the data by different keys. 
    <b>Boost.MultiIndex</b> offers efficient query and update operations for 
    the stored data and alleviates the need for a custom sophisticated and error prone 
    synchronization of <i>indices</i>.     
    </p>

    <p>
    An augmented B+ tree represents from the user perspective a single container 
    that has a structure more complex than a basic search tree. The augmented tree 
    stores elements of the user data set in external nodes. In internal nodes 
    this tree stores additional implementation specific data associated with 
    the user data set. These additional data help extend STL facilities through 
    the performance improvement of various algorithms. The method of multiple 
    augmenting can be summarized as follows. A balanced tree provides efficient 
    search operations by a key and supports STL associative containers only. 
    The tree augmented by the counter of container elements has the extended 
    functionality. It adds efficient access to n-th element of a container. 
    This tree supports not only STL associative containers, but also STL sequences. 
    Yet another augmenting by the sum of values of container element adds 
    the efficient algorithm for the function <code>accumulate()</code>.     
    </p>
    

    <h4>
    Advantage of Boost.MultiIndex
    </h4>

    <p>
    STL containers based on the augmented B+ trees obtain member functions 
    with improved efficiency against containers using basic search trees. 
    It is also important to note that despite multiple augmenting of the B+ trees 
    these STL containers efficiently support search by one type of a key only. 
    For these reasons, each variant of an STL container using an augmented B+ tree 
    is equivalent to a single <i>index</i> of <b>Boost.MultiIndex</b>.
    In complex applications that process a data set using several keys 
    a container based on an augmented B+ tree should be less efficient 
    than a <code>multi_index_container</code> with properly selected <i>indices</i>.
    To demonstrate an example of the superiority of <b>Boost.MultiIndex</b> consider 
    a data set of three dimensional points with coordinates <code>{x, y, z}</code>.
    A <code>multi_index_container</code> can store the data set in a <i>sequenced 
    index</i> and provide efficient search operations for each coordinate through 
    three <i>ordered indices</i>. A container based on an augmented B+ tree, 
    such as <code>multiset</code>, supports logarithmic search by one coordinate 
    and linear search by two other coordinates.    
    </p>


    <h4>
    Boost.MultiIndex emulation of STL containers
    </h4>
    
    <p>
    <b>Boost.MultiIndex</b> can 
    <a href="http://www.boost.org/doc/libs/1_51_0/libs/multi_index/doc/tutorial/techniques.html#emulate_std_containers">
    emulate a single STL container
    </a>
    , when the class template <code>multi_index_container</code> 
    is used with one <i>index</i> only. 
    This is a relatively simple case of the comparison of containers of two libraries. 
    It is similar to the comparison with the <b>Boost.Container</b> library. 
    In general, advanced data structures offer more efficient operations 
    for user algorithms. If an algorithm supports interchangeable STL containers 
    then performance measurements can help choose the best container. 
    </p>
    
    
    <h4>
    Boost.MultiIndex emulation of complex data structures
    </h4>
    
    <p>
    The other interesting feature of <b>Boost.MultiIndex</b> is     
    the emulation of complex data structures. The documentation section 
    <a href="http://www.boost.org/doc/libs/1_51_0/libs/multi_index/doc/tutorial/basics.html#list_fast_lookup">    
    Bidirectional list with fast look up
    </a> 
    discusses an example of a <code>multi_index_container</code> using 
    a linked list through <i>sequenced index</i> and a red-black tree 
    through <i>ordered index</i>.     
    </p>        
    

    <p>
    The combination of a sequence with a red-black tree is equivalent to a B+ tree 
    that stores container elements in external nodes and keys in internal nodes. 
    The difference is that the B+ tree stores the keys in a B-tree instead of a red-black tree. 
    Thus, this example of the <code>multi_index_container</code> 
    with two <i>indices</i> is equivalent to 
    <a href="https://github.com/vstadnik/stl_ext_adv">a dynamically allocated basic search B+ tree</a>. 
    This variant of a B+ tree supports STL associative containers with bidirectional 
    iterators. However, unlike all the augmented B+ trees, it does not offer 
    any extension of STL facilities. 
    </p>

    <p>
    On the other hand, the similar combination of <i>random access index</i> with 
    <i>ordered index</i> does not look like a good alternative to an augmented 
    B+ tree with random access iterators. Compared to the discussed example, 
    a <code>multi_index_container</code> with these two <i>indices</i> 
    improves efficiency of access to data through random access iterators. 
    However, this improvement is quite costly for algorithms that update the data set, 
    since insertion and erasure operations in <i>random access index</i> have linear 
    complexity against constant and logarithmic complexity of <i>sequenced</i> 
    and <i>ordered indices</i>. Moreover, this combination of <i>indices</i> 
    can be hardly more useful than a flat associative container of the 
    <b>Boost.Container</b> library that offers much better locality of reference. 
    In contrast, the augmented B+ trees provide the same update operations 
    with logarithmic running time.     
    </p>

    <p>
    The disadvantage of the <b>Boost.MultiIndex</b> emulation of complex data 
    structures is that the efficiency of a <code>multi_index_container</code> 
    operation is determined by the least efficient operation of one of its <i>indices</i>. 
    A wrong combination of <i>indices</i> can result in a significant loss of 
    performance of an application using such a <code>multi_index_container</code>.     
    In order to successfully compete with a complex advanced data structure 
    each <i>index</i> of a <code>multi_index_container</code> must provide operations 
    at least as efficient as the matching operations of the advanced data structure. 
    The other potential problem of the <b>Boost.MultiIndex</b> emulation is that 
    it can require more space than a corresponding optimally designed 
    complex data structure.     
    </p>


    <h4>
    Update operations
    </h4>
    
    <p>
    <b>Boost.MultiIndex</b> imposes restrictions on update operations 
    in order to preserve invariants of all <i>indices</i> of 
    a <code>multi_index_container</code>. The elements of <i>indices</i> 
    that represent counterparts of STL containers can be modified only 
    through special non-standard member functions, such as <code>replace()</code>.     
    </p>

    <p>
    The basic search B+ trees and B+ trees augmented with the counter of 
    container elements do not have the problem of data invalidation. 
    It arises only for the augmented B+ trees that support logarithmic time 
    algorithm <code>accumulate()</code>. This fact suggests that the problem 
    becomes more significant as the complexity of a data structure increases. 
    The new non-standard member function 
    <a href="bp_trees_design.html#write_oper"><code>write()</code></a> 
    has been added to address this problem. 
    It matches the <b>Boost.MultiIndex</b> function <code>replace()</code>.   
    </p>
    
    
    <h4>
    User defined indices
    </h4>
    
    <p>
    The restrictions imposed on <i>indices</i> make it impossible to use 
    <b>Boost.MultiIndex</b> with standard containers, such as <code>std::vector</code>. 
    It is even more important that these restritions do not allow 
    to take full advantage of many types of augmented data structures that 
    offer significant performance benefit against basic data structures.
    </p>

    <p>
    The <b>Boost.MultiIndex</b> documentation mentions the option of 
    the development of user defined <i>indices</i>, although the requirements 
    have not been specified yet. The array based B+ trees cannot be used 
    for this purpose, since they do not remain stable after update operations. 
    The 
    <a href="https://github.com/vstadnik/stl_ext_adv">dynamically allocated B+ trees</a> 
    do not have this problem and, thus, they are more suitable candidates. 
    </p>

    <p>
    The section 
    <a href="http://www.boost.org/doc/libs/1_51_0/libs/multi_index/doc/future_work.html">Future work</a>     
    discusses new <i>ranked indices</i> for order-statistics trees that represent 
    augmented red-black trees. It is not clear, however, if every new augmented 
    data structure would require its special <i>index</i>. In theory, the standard containers 
    can support <b>Boost.MultiIndex</b> through container adapters. This approach 
    could be more beneficial, since it would allow using any data structure 
    that can provide interfaces of STL containers and iterators. 
    </p>
    
  
  <hr>

  <p><a href="http://validator.w3.org/check?uri=referer"><img border="0" src=
  "images/valid-html401.png" alt="Valid HTML 4.01 Transitional"
  height="31" width="88"></a></p>

  <p>Revised 
  <!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->
  02 February, 2013<!--webbot bot="Timestamp" endspan i-checksum="38514" --></p>

  <p><i>Copyright &copy; 2011-2012</i> 
  <a href="mailto:vadimstdk@gmail.com"><i>Vadim Stadnik</i><br>(vadimstdk@gmail.com)</a>
  </p>

  <p><i>Distributed under the Boost Software License, Version 1.0. (See
  accompanying file <a href="images/LICENSE_1_0.txt">LICENSE_1_0.txt</a> or
  copy at <a href=
  "http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>
  
  
  <hr>  
  <div align="right">
    <a href="introduction.html"><img src="images/prev.png" border=0 alt="Prev"></a>
    <a href="../index.html"><img src="images/up.png" border=0 alt="Up"></a>
    <a href="../index.html"><img src="images/home.png" border=0 alt="Home"></a>
    <a href="examples.html"><img src="images/next.png" border=0 alt="Next"></a>    
  </div> 
  
  
</body>
</html>
